@using Microsoft.AspNetCore.Components
@inject IJSRuntime JSRuntime

<div class="rich-editor-container">
    <div class="editor-toolbar">
        <div class="toolbar-group">
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("bold"))" title="Bold">
                <i class="fas fa-bold"></i>
            </button>
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("italic"))" title="Italic">
                <i class="fas fa-italic"></i>
            </button>
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("underline"))" title="Underline">
                <i class="fas fa-underline"></i>
            </button>
        </div>
        
        <div class="toolbar-separator"></div>
        
        <div class="toolbar-group">
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("justifyLeft"))" title="Align Left">
                <i class="fas fa-align-left"></i>
            </button>
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("justifyCenter"))" title="Align Center">
                <i class="fas fa-align-center"></i>
            </button>
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("justifyRight"))" title="Align Right">
                <i class="fas fa-align-right"></i>
            </button>
        </div>
        
        <div class="toolbar-separator"></div>
        
        <div class="toolbar-group">
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("insertUnorderedList"))" title="Bullet List">
                <i class="fas fa-list-ul"></i>
            </button>
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("insertOrderedList"))" title="Numbered List">
                <i class="fas fa-list-ol"></i>
            </button>
        </div>
        
        <div class="toolbar-separator"></div>
        
        <div class="toolbar-group">
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("createLink"))" title="Insert Link">
                <i class="fas fa-link"></i>
            </button>
            <button type="button" class="editor-btn" @onclick="@(() => ExecCommand("unlink"))" title="Remove Link">
                <i class="fas fa-unlink"></i>
            </button>
        </div>
        
        <div class="toolbar-separator"></div>
        
        <div class="toolbar-group">
            <select class="editor-select" @onchange="FormatBlock">
                <option value="">Format</option>
                <option value="p">Paragraph</option>
                <option value="h1">Heading 1</option>
                <option value="h2">Heading 2</option>
                <option value="h3">Heading 3</option>
                <option value="h4">Heading 4</option>
            </select>
        </div>
        
        <div class="toolbar-separator"></div>
        
        <div class="toolbar-group">
            <button type="button" class="editor-btn" @onclick="ToggleSourceMode" title="View Source">
                <i class="fas fa-code"></i>
            </button>
        </div>
    </div>
    
    @if (!isSourceMode)
    {
        <div @ref="editorElement" 
             class="editor-content @(IsRtl ? "rtl" : "")" 
             contenteditable="true"
             @oninput="OnContentChanged"
             @onpaste="OnPaste"
             style="min-height: @(Height)px; direction: @(IsRtl ? "rtl" : "ltr");">
        </div>
    }
    else
    {
        <textarea @ref="sourceElement" 
                  class="editor-source" 
                  @bind="sourceContent" 
                  @oninput="OnSourceChanged"
                  style="height: @(Height)px; direction: @(IsRtl ? "rtl" : "ltr");"></textarea>
    }
</div>

<style>
.rich-editor-container {
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    background: white;
}

.editor-toolbar {
    display: flex;
    align-items: center;
    padding: 8px 12px;
    background: #f8f9fa;
    border-bottom: 1px solid #dee2e6;
    border-radius: 0.375rem 0.375rem 0 0;
    flex-wrap: wrap;
    gap: 4px;
}

.toolbar-group {
    display: flex;
    align-items: center;
    gap: 2px;
}

.toolbar-separator {
    width: 1px;
    height: 24px;
    background: #dee2e6;
    margin: 0 4px;
}

.editor-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 32px;
    height: 32px;
    border: 1px solid transparent;
    background: transparent;
    border-radius: 4px;
    cursor: pointer;
    color: #495057;
    font-size: 14px;
    transition: all 0.15s ease;
}

.editor-btn:hover {
    background: #e9ecef;
    border-color: #adb5bd;
}

.editor-btn:active,
.editor-btn.active {
    background: #0d6efd;
    color: white;
    border-color: #0d6efd;
}

.editor-select {
    padding: 4px 8px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    background: white;
    min-width: 100px;
}

.editor-content {
    padding: 12px;
    min-height: 150px;
    outline: none;
    line-height: 1.5;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    font-size: 14px;
    color: #495057;
    overflow-y: auto;
}

.editor-content.rtl {
    text-align: right;
}

.editor-content:focus {
    box-shadow: 0 0 0 0.2rem rgba(13, 110, 253, 0.25);
}

.editor-content p {
    margin: 0 0 10px 0;
}

.editor-content h1, .editor-content h2, .editor-content h3, .editor-content h4 {
    margin: 10px 0;
    font-weight: 600;
}

.editor-content ul, .editor-content ol {
    margin: 10px 0;
    padding-left: 30px;
}

.editor-content.rtl ul, .editor-content.rtl ol {
    padding-left: 0;
    padding-right: 30px;
}

.editor-content a {
    color: #0d6efd;
    text-decoration: underline;
}

.editor-source {
    width: 100%;
    padding: 12px;
    border: none;
    outline: none;
    resize: vertical;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.4;
    background: #f8f9fa;
}

.editor-content blockquote {
    margin: 10px 0;
    padding: 10px 15px;
    border-left: 4px solid #dee2e6;
    background: #f8f9fa;
    font-style: italic;
}

.editor-content.rtl blockquote {
    border-left: none;
    border-right: 4px solid #dee2e6;
}
</style>

@code {
    [Parameter] public string Value { get; set; } = "";
    [Parameter] public EventCallback<string> ValueChanged { get; set; }
    [Parameter] public bool IsRtl { get; set; } = false;
    [Parameter] public int Height { get; set; } = 200;
    [Parameter] public string Placeholder { get; set; } = "";
    
    private ElementReference editorElement;
    private ElementReference sourceElement;
    private bool isSourceMode = false;
    private string sourceContent = "";
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                await SetInitialContent();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error in OnAfterRenderAsync: {ex.Message}");
            }
        }
    }
    
    protected override async Task OnParametersSetAsync()
    {
        try
        {
            if (!string.IsNullOrEmpty(Value) && !isSourceMode)
            {
                await SetEditorContent(Value);
            }
            sourceContent = Value ?? "";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in OnParametersSetAsync: {ex.Message}");
        }
    }
    
    private async Task SetInitialContent()
    {
        try
        {
            // Add small delay to ensure DOM is ready
            await Task.Delay(50);
            
            if (!string.IsNullOrEmpty(Value))
            {
                await SetEditorContent(Value);
            }
            else if (!string.IsNullOrEmpty(Placeholder))
            {
                await JSRuntime.InvokeVoidAsync("setPlaceholder", editorElement, Placeholder);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error setting initial content: {ex.Message}");
        }
    }
    
    private async Task SetEditorContent(string content)
    {
        try
        {
            await JSRuntime.InvokeVoidAsync("setEditorContent", editorElement, content ?? "");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error setting editor content: {ex.Message}");
        }
    }
    
    private async Task ExecCommand(string command)
    {
        if (command == "createLink")
        {
            var url = await JSRuntime.InvokeAsync<string>("prompt", "Enter URL:");
            if (!string.IsNullOrEmpty(url))
            {
                await JSRuntime.InvokeVoidAsync("execCommand", command, false, url);
            }
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("execCommand", command, false, null);
        }
        await OnContentChanged();
    }
    
    private async Task FormatBlock(ChangeEventArgs e)
    {
        var format = e.Value?.ToString();
        if (!string.IsNullOrEmpty(format))
        {
            await JSRuntime.InvokeVoidAsync("execCommand", "formatBlock", false, format);
            await OnContentChanged();
        }
    }
    
    private async Task OnContentChanged()
    {
        try
        {
            if (!isSourceMode)
            {
                var content = await JSRuntime.InvokeAsync<string>("getEditorContent", editorElement);
                await ValueChanged.InvokeAsync(content ?? "");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in OnContentChanged: {ex.Message}");
        }
    }
    
    private async Task OnSourceChanged()
    {
        try
        {
            await ValueChanged.InvokeAsync(sourceContent ?? "");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in OnSourceChanged: {ex.Message}");
        }
    }
    
    private async Task OnPaste()
    {
        // Clean up pasted content after a short delay
        await Task.Delay(100);
        await OnContentChanged();
    }
    
    private async Task ToggleSourceMode()
    {
        if (isSourceMode)
        {
            // Switch from source to visual
            isSourceMode = false;
            StateHasChanged();
            await Task.Delay(100); // Wait for DOM update
            await SetEditorContent(sourceContent);
        }
        else
        {
            // Switch from visual to source
            var content = await JSRuntime.InvokeAsync<string>("getEditorContent", editorElement);
            sourceContent = content;
            isSourceMode = true;
            StateHasChanged();
        }
    }
}

<script>
window.setEditorContent = (element, content) => {
    try {
        if (element && element.nodeType === Node.ELEMENT_NODE) {
            element.innerHTML = content || '';
        }
    } catch (error) {
        console.warn('Error setting editor content:', error);
    }
};

window.getEditorContent = (element) => {
    try {
        return (element && element.nodeType === Node.ELEMENT_NODE) ? element.innerHTML : '';
    } catch (error) {
        console.warn('Error getting editor content:', error);
        return '';
    }
};

window.setPlaceholder = (element, placeholder) => {
    try {
        if (element && element.nodeType === Node.ELEMENT_NODE && element.innerHTML.trim() === '') {
            element.innerHTML = `<p style="color: #6c757d; font-style: italic;">${placeholder}</p>`;
        }
    } catch (error) {
        console.warn('Error setting placeholder:', error);
    }
};

window.execCommand = (command, showUI, value) => {
    try {
        if (document.queryCommandSupported && document.queryCommandSupported(command)) {
            document.execCommand(command, showUI, value);
        }
    } catch (error) {
        console.warn('Error executing command:', command, error);
    }
};

// Clean up formatting on paste
document.addEventListener('paste', function(e) {
    try {
        if (e.target && e.target.classList && e.target.classList.contains('editor-content')) {
            setTimeout(() => {
                try {
                    // Remove unwanted attributes and clean up
                    const editor = e.target;
                    if (editor && editor.querySelectorAll) {
                        const elements = editor.querySelectorAll('*');
                        elements.forEach(el => {
                            try {
                                // Remove style attributes from pasted content
                                if (el.removeAttribute) {
                                    el.removeAttribute('style');
                                    el.removeAttribute('class');
                                }
                                
                                // Remove empty elements safely
                                if (el.innerHTML !== undefined && el.innerHTML.trim() === '' && 
                                    !['BR', 'HR'].includes(el.tagName) && 
                                    el.parentNode) {
                                    el.parentNode.removeChild(el);
                                }
                            } catch (innerError) {
                                console.warn('Error cleaning element:', innerError);
                            }
                        });
                    }
                } catch (cleanupError) {
                    console.warn('Error during paste cleanup:', cleanupError);
                }
            }, 100);
        }
    } catch (error) {
        console.warn('Error handling paste event:', error);
    }
});

// Handle placeholder behavior
document.addEventListener('focus', function(e) {
    try {
        if (e.target && e.target.classList && e.target.classList.contains('editor-content')) {
            const placeholder = e.target.querySelector && e.target.querySelector('p[style*="font-style: italic"]');
            if (placeholder && placeholder.style && placeholder.style.color === 'rgb(108, 117, 125)') {
                e.target.innerHTML = '';
            }
        }
    } catch (error) {
        console.warn('Error handling focus event:', error);
    }
}, true);

document.addEventListener('blur', function(e) {
    try {
        if (e.target && e.target.classList && e.target.classList.contains('editor-content')) {
            if (e.target.innerHTML && (e.target.innerHTML.trim() === '' || e.target.innerHTML === '<br>')) {
                const placeholder = e.target.getAttribute && e.target.getAttribute('data-placeholder');
                if (placeholder) {
                    e.target.innerHTML = `<p style="color: #6c757d; font-style: italic;">${placeholder}</p>`;
                }
            }
        }
    } catch (error) {
        console.warn('Error handling blur event:', error);
    }
}, true);
</script>